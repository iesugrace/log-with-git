#!/usr/bin/env python3
# Author: Joshua Chen
# Date: 2016-01-03
# Location: Shenzhen
# Description: a log tool with encrypted remote backup.

import sys, os
import base64
import re
import time
from subprocess import Popen, PIPE

prog_path = os.path.realpath(__file__)
prog_dir  = os.path.dirname(prog_path)
lib_dir   = os.path.join(prog_dir, 'lib')
sys.path.insert(0, lib_dir)

from common import editContent
import interact
import timeutils
import lib

data_dir = os.path.join(prog_dir, 'data')


class Record:
    """ Define the fields and methods of a record
    Fields and types:
    subject  --  str
    time     --  int
    scene    --  str
    people   --  str
    tag      --  str
    data     --  str (maybe base64 text for binary data)
    """
    sep = ': '  # separator between key and value

    def __init__(self, subject, time=None, scene='',
                        people='', tag='', data=''):
        time = time if time else timeutils.isodatetime()
        self.subject   =  subject
        self.time      =  timeutils.strtosecond(time)
        self.scene     =  scene
        self.people    =  people
        self.tag       =  tag
        self.data      =  data

    def __repr__(self):
        text = self.__header()
        if self.binary:
            data = "-->> Binary data <<--\n"
        else:
            data = self.data
        text = '%s\n\n%s' % (text, data)
        return text

    def __header(self):
        """ Construct the header of the Log
        Return a str object, no ending new-line.
        """
        text = 'Subject%s%s\nTime%s%s\nScene%s%s\nPeople%s%s\nTag%s%s'
        text = text % (self.sep, self.subject,
                       self.sep, timeutils.isodatetime(self.time),
                       self.sep, self.scene,
                       self.sep, self.people,
                       self.sep, self.tag)
        return text

    def elements(self):
        """ Return a dictionary containing
        all elements of the record
        """
        return self.__dict__


class Git:
    """ Git related operations
    """
    def __init__(self, gitDir=None, gitWorkTree=None):
        if gitWorkTree is None:
            gitWorkTree = data_dir
        if gitDir is None:
            gitDir = os.path.join(gitWorkTree, '.git')
        self.gitWorkTree = gitWorkTree
        self.gitDir      = gitDir
        if not os.path.exists(gitDir):
            self.init()

    def commit(self, path, title):
        """ Add the file of path and create a commit
        """
        cmd = ['git', 'add', path]
        res = self.runCmd(cmd)
        if not res[0]:
            return False
        cmd = ['git', 'commit', '-m', title]
        self.runCmd(cmd)

    def init(self):
        """ Initialize a git repository
        """
        cmd = ['git', 'init']
        self.runCmd(cmd)

    def runCmd(self, cmd):
        """ Setup environment and execute command
        """
        os.environ.putenv('GIT_WORK_TREE', self.gitWorkTree)
        os.environ.putenv('GIT_DIR', self.gitDir)
        res = lib.get_status_byte_output(cmd)
        if not res[0]:
            print('git command failed:', file=sys.stderr)
            print(res[2].decode(), file=sys.stderr, end='')
        return res

    def last(self):
        """ Return the file content of the last commit
        it shall be one file only.
        """
        return None


class LogRecord(Record):
    """ Log Record capable of Git operations
    OS aware operations defined here.
    """
    def __init__(self, subject, time=None, scene='',
                 people='', tag='', data='', binary=False):
        Record.__init__(self, subject, time, scene, people, tag, data)
        self.binary = binary
        self.git    = Git()

    def save(self):
        """ Save instance data to disk, and create a git commit
        """
        timestamp  =  self.time
        dateEle    =  timeutils.isodate(timestamp).split('-')
        relDirPath =  os.path.join(*dateEle)
        absDirPath =  os.path.join(data_dir, relDirPath)
        fileName   =  self.genName(timestamp)
        filePath   =  os.path.join(absDirPath, fileName)
        os.makedirs(absDirPath, exist_ok=True)
        self.engine.save(self, filePath)

        relPath    =  os.path.join(relDirPath, fileName)
        msgTitle   =  timeutils.isodatetime(self.time)
        self.git.commit(relPath, msgTitle)

    def genName(self, timestamp):
        """ Generate a random file name base on the timestamp
        """
        import random
        s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
        res = ''
        length = 10
        for i in range(length):
            res += random.choice(s)
        return '%s%s' % (timestamp, res)

    @staticmethod
    def binToAsc(binData):
        """ Convert the binary data into ASCII form,
        using the registered storage engine.
        """
        return LogRecord.engine.b64encode(binData)

    @staticmethod
    def load(path):
        return LogRecord.engine.load(path)


class XmlStorage:
    """ XML storage engine for the record
    """
    @staticmethod
    def b64encode(iData, lineLen=64):
        """ Take the data which is a bytes,
        encode it with base64, split the resulting
        text into lines of 'lineLen', decode each
        line (it was a bytes) to str, concatenate
        them and return them as a whole long line.
        """
        lineLen = lineLen // 4 * 4  # make it times of 4
        oData   = base64.b64encode(iData)
        res     = []
        while oData:
            line, oData = oData[:lineLen], oData[lineLen:]
            res.append(line.decode())
        return '\n'.join(res)

    @staticmethod
    def b64decode(iData):
        """ Take the str, decode it into binary
        """
        iData = iData.replace('\n', '')
        return base64.b64decode(iData)

    @staticmethod
    def sourceToDom(code):
        """ Parse the raw record data which is XML code,
        return a Xml DOM object.
        """
        from xml.dom.minidom import parseString
        return parseString(code)

    @staticmethod
    def load(path):
        """ Load the content of the path,
        parse it, and return a record instance.
        """
        try:
            code = open(path).read()
            doc  = XmlStorage.sourceToDom(code)
        except:
            return None
        fields = {}
        for node in doc.firstChild.childNodes:
            if node.nodeType == node.ELEMENT_NODE:
                name = node.localName
                textNode = node.firstChild
                data = textNode.data if textNode else ''
                fields[name] = data
        fields['binary'] = True if fields['binary'] == 'true' else False
        return LogRecord(**fields)

    @staticmethod
    def createNode(root, nodeName, nodeText):
        """ Add an element node with nodeText to the 'root' element
        """
        from xml.dom.minidom import Element, Text
        ele = Element(nodeName)
        text = Text()
        text.data = nodeText
        ele.appendChild(text)
        root.appendChild(ele)

    @staticmethod
    def recordToSource(record):
        """ Compose Xml source code from a record object
        """
        from xml.dom.minidom import Document, Text
        import re
        doc  = Document()
        root = doc.createElement("log")
        doc.appendChild(root)
        XmlStorage.createNode(root, "subject", record.subject)
        XmlStorage.createNode(root, "time", timeutils.isodatetime(record.time))
        XmlStorage.createNode(root, "scene", record.scene)
        XmlStorage.createNode(root, "people", record.people)
        XmlStorage.createNode(root, "tag", record.tag)
        if record.binary:
            XmlStorage.createNode(root, "binary", "true")
        else:
            XmlStorage.createNode(root, "binary", "false")
        XmlStorage.createNode(root, "data", record.data)
        xmlCode = doc.toprettyxml()
        xmlCode = re.sub('\n(\s*\n)*', '\n', xmlCode)  # remove empty lines
        xmlCode = re.sub('\t', '    ', xmlCode)     # replace tabs with spaces
        return xmlCode

    @staticmethod
    def save(record, path):
        """ Convert the record to Xml code,
        and Write the code to the path.
        """
        code = XmlStorage.recordToSource(record)
        open(path, 'w').write(code)


# Register storage engine
LogRecord.engine = XmlStorage


class Log:
    """ All log operations defined here
    """

    def __init__(self):
        self.git = Git()

    def lastScene(self):
        """ Fetch the recently used scene from the history
        """
        path = self.git.last()
        if path != None:
            record = LogRecord.engine.load(path)
            if record != None:
                return record.scene
        return ''

    def add(self, subject=None, time=None, scene='',
                    people='', tag='', data=b'', interactive=False):
        """ Add a log record to the system
        When interactive is True, ask data for subject, time, scene,
        people, tag, and log data from the use interactively, the
        provided arguments are used as the default value for user's
        choice.
        """
        if data:    # data provided, non-interactively
            if self.isBinary(data):
                binary = True
                data   = LogRecord.binToAsc(data)
            else:
                binary = False
                data = data.decode()
        else:
            binary = False

        if interactive:
            record = self.makeLogEntry(subject=subject, time=time, scene=scene,
                        people=people, tag=tag, data=data, binary=binary)
        else:
            assert (subject != None and subject != ''), "invalid subject"
            record = LogRecord(subject, time, scene, people, tag, data, binary)
        record.save()

    def isBinary(self, data):
        """ Deem to be binary data if failed to decode with utf8
        """
        try:
            data.decode('utf8')
        except UnicodeDecodeError:
            return True
        else:
            return False

    def makeOneRequest(self, name, default, datatype, reader, desc):
        """ Create a request entry, used to interactively collect
        information from the user. A request is a dictionary object
        that contains necessary information to interact with the user.
        """
        suffix = (' [%s]: ' % default) if default else ': '
        prompt = desc + suffix
        if reader:
            actual_reader = (lambda prompt, default: reader(prompt, default))
        else:
            actual_reader = reader
        return dict(name=name, prompt=prompt, datatype=datatype,
                    default=default, reader=actual_reader)

    def makeRequests(self, *, record=None, subject=None, time=None,
                    scene=None, people=None, tag=None):
        """ Create the necessary requests data for collecting
        information for a Record from the user interactively.
        """
        if record:      # a LogRecord instance provided
            subject  =  record.subject
            time     =  record.time
            scene    =  record.scene
            people   =  record.people
            tag      =  record.tag
        else:
            subject = subject if subject else None
            time = time if time else timeutils.isodatetime()
            scene = scene if scene else self.lastScene()
            people = people if people else ''
            tag = tag if tag else ''

        requests = []
        # arguments: name, default, datatype, reader, desc
        requests.append(self.makeOneRequest('subject', subject, str, None, 'subject'))
        requests.append(self.makeOneRequest('time',    time,    str, None, 'time'))
        requests.append(self.makeOneRequest('scene',   scene,   str, None, 'scene'))
        requests.append(self.makeOneRequest('people',  people,  str, None, 'people'))
        requests.append(self.makeOneRequest('tag',     tag,     str, None, 'tag'))
        return requests

    def makeLogEntry(self, *junk, **args):
        """ Make a LogRecord instance interactively
        'data' in the args must be a bytes which can
        be decoded using utf8, binary data that is
        not utf8 encoded, is not applicable.
        """
        data     =  args.pop('data')
        binary   =  args.pop('binary')
        requests = self.makeRequests(**args)
        i        = interact.readMany(requests)
        subject  =  i['subject']
        time     =  i['time']
        scene    =  i['scene']
        people   =  i['people']
        tag      =  i['tag']
        data   = editContent(data).decode()
        record = LogRecord(subject, time, scene, people, tag, data, binary)
        return record

    def collectLogs(self, filter=None):
        """ Walk through all log records, collect those
        that passed the filter function matching. Return
        a list of LogRecord instances.
        """
        if not filter:
            filter = lambda record: True

        cmd = ['find', data_dir, '-name', '.git', '-prune', '-o', '-type', 'f', '-print0']
        res = lib.get_status_byte_output(cmd)
        if not res[0]:
            print('find command failed:', file=sys.stderr)
            print(res[2].decode(), file=sys.stderr, end='')
            return []

        lines = res[1].split(b'\x00')[:-1]   # remove the last empty one
        paths = [x.decode() for x in lines]
        records = []
        for path in paths:
            record = LogRecord.load(path)
            if filter(record):
                records.append(record)
        return records


def add(args):
    """ Add a log
    Subject must be provided, all others are optional.
    If data is provided, run in non-interactive mode,
    if stdin is not a tty, run in non-interactive mode,
    otherwise, collect information interactively.
    """
    tag = time = scene = people = subject = data = ''
    interactive = True
    while len(args) >= 2:
        key = args.pop(0)
        if key == '-g':
            tag = args.pop(0)
        elif key == '-t':
            time = args.pop(0)
        elif key == '-c':
            scene = args.pop(0)
        elif key == '-p':
            people = args.pop(0)
        elif key == '-s':
            subject = args.pop(0)
        elif key == '-d':
            data = args.pop(0)
            data = data.rstrip('\n')    # remove all ending new-lines
    assert (subject != None and subject != ''), "invalid subject"
    if data:        # data provided
        interactive = False
        data = data.encode()
    elif not os.isatty(sys.stdin.fileno()):
        interactive = False
        stdin = os.fdopen(sys.stdin.fileno(), 'rb')
        data = stdin.read()
    logger = Log()
    logger.add(subject, time, scene, people, tag, data, interactive)


def _list(args):
    """ List log summary

    Can match log entries by time, or by regular expression.

    Time format (implemented in compreDay):
        today: the day when the command runs
        negative number: N-th day ago (-1, -70)
        one or two digit number: a day of a month (1, 12)
        four digit number: a day of the specific month  (0413, 0314)
        four digit number: a year  (2015, 2016)
        six digit number: a month of a year  (201512, 201601)
        eight digit number: a day of a month of a year  (20160101)

    Time contextual meaning (implemented in parseTime):
        a. pure number/word: from the first second of it,
                             to the last second of it
        b. colon separated : from the first second of the first,
                             to the last second of the second,
                             'today' next to the colon can be omitted.
        c. comma separated: combination of 'a' or 'b' types
    """
    if len(args) == 0:  # list all records
        filterFunc = lambda record: True
    else:
        filterFunc = procArgs(args)
    logger  = Log()
    records = logger.collectLogs(filterFunc)
    records = sorted(records, key=lambda x: x.time, reverse=True)
    pageOut(records)


def pageOut(records):
    """ Apply color to the text, pipe the
    text to a pager, for a better viewing.
    """
    def colorize(record):
        """ Render the first line
        """
        text    = str(record)
        pos     = text.find('\n')
        subject = text[:pos]
        cFormat = '\033[0;33m%s\033[0m'
        subject = cFormat % subject
        return subject + text[pos:]

    lastOne = records.pop()
    pager   = lib.Pager(['-XRF'])
    for record in records:
        pager.write(colorize(record), '\n\n', isBytes=False)
    pager.write(colorize(lastOne), '\n', isBytes=False)
    pager.go()


def procArgs(args):
    """ Process the arguments, return a filter function.
    """
    regexps    = []
    matchAll   = False
    timePoints = []
    while args:
        arg = args.pop(0)
        if arg[:2] == '-S':     # regular expression
            if len(arg) > 2:
                regexps.append(arg[2:])
            else:
                assert len(args) > 0, "need argument for -S option"
                regexps.append(args.pop(0))
        elif arg == '--all-match':  # affects the RE evaluation
            matchAll = True
        else:   # time
            assert validateTime(arg), ("invalid time: %s" % arg)
            timePoints.extend(parseTime(arg))
    return makeFilter(timePoints, regexps, matchAll)


def validateTime(timeStr):
    """ Check the time string format
    Only check the textual format, not the meaning
    of the time string, therefore 20160230 is valid.
    """
    if timeStr == 'today':
        return True

    lev1_parts = timeStr.split(',')
    for lev1_part in lev1_parts:
        lev2_parts = lev1_part.split(':')
        for x in lev2_parts:
            # empty means 'today'
            regexp = '^(today|-[0-9]+|[0-9]{1,2}|[0-9]{4}|[0-9]{6}|[0-9]{8})?$'
            if re.search(regexp, x) is None:
                return False
    return True


def parseTime(timeStr):
    """ Parse the time string, return a list of lists,
    every inner list represents a period of time between
    two points, the relationship between all inner lists
    is OR, not AND.
    """
    if timeStr == 'today':
        return [todayPeriod()]

    allPairs   = []
    lev1_parts = timeStr.split(',')
    for lev1_part in lev1_parts:
        lev2_parts = lev1_part.split(':')
        if len(lev2_parts) == 2: # start time and end time
            firstSecond, junk = compreTime(lev2_parts[0])
            junk, lastSecond  = compreTime(lev2_parts[1])
            allPairs.append([firstSecond, lastSecond])
        else:   # one time
            pair = compreTime(lev2_parts[0])
            allPairs.append(pair)
    return allPairs


def todayPeriod():
    """ Return the first and the last seconds of today
    """
    return dayPeriod()


def dayPeriod(ts=None):
    """ Return the first and the last seconds
    of a day, 'ts' is a time.struct_time object,
    if omitted, assume the current time.
    """
    if ts is None:
        ts = time.localtime()
    ts1 = time.strptime('%d%02d%02d' % ts[:3], '%Y%m%d')
    firstSecond = int(time.mktime(ts1))
    timeStr = '%d%02d%02d%02d%02d%02d' % (ts[:3] + (23, 59, 59))
    ts2 = time.strptime(timeStr, '%Y%m%d%H%M%S')
    lastSecond  = int(time.mktime(ts2))
    return [firstSecond, lastSecond]


def compreTime(text):
    """ Distinguish between year and other
    time format, call compreYear and compreDay
    accordingly. Empty string means 'today'.
    """
    if not text:
        return todayPeriod()
    if len(text) == 4 and text[:2] == '20':
        return compreYear(text)
    else:
        return compreDay(text)


def compreYear(text):
    """ Take the given number string as a year, return
    the first second and the last second of the year.
    """
    firstDay = time.strptime(text, '%Y')
    lastDay  = time.strptime('%s%s%s' % (text, '12', '31'), '%Y%m%d')
    firstSecond, junk = dayPeriod(firstDay)
    junk, lastSecond  = dayPeriod(lastDay)
    return [firstSecond, lastSecond]


def compreDay(text):
    """ Parse the given number string, return the
    first second and the last second of the day.
    """
    l = len(text)

    try:
        if text[0] == '-':          # negative day
            days = int(text)
            second = time.time() + 86400 * days
            res = time.localtime(second)
        elif 1 <= l <= 2:           # a day of the current month
            y, m = time.localtime()[:2]
            d = int(text)
            res = time.strptime('%s%02d%02d' % (y, m, d), '%Y%m%d')
        elif l == 4:                # day of a specific month
            y = time.localtime()[0]
            res = time.strptime('%s%s' % (y, text), '%Y%m%d')
        elif l == 6:                # month of a specific year
            res = time.strptime(text, '%Y%m')
        elif l == 8:                # a day of a month of a year
            res = time.strptime(text, '%Y%m%d')
    except:
        raise lib.InvalidTimeException("invalid time: %s" % text)
    return dayPeriod(res)


def makeFilter(timePoints, regexps, matchAll=False):
    """ Create a filter function for filtering
    the record with the given regular expression,
    and the time points. The filter function
    expects a LogRecord instance object.
    """
    def logFilter(record, regexps=regexps,
                timePoints=timePoints, matchAll=matchAll):
        """ timeMatch is True if the time of the record is
        within any pair of the timePoints, regMatch is True
        if any of these fields of a record match the given
        regular expression: subject, scene, people, tag,
        and data if it's not of binary form. Return True
        only when both timeMatch and regMatch are True.
        """
        timeMatch = regMatch = True
        if timePoints:
            t = record.time
            x = [True for t1, t2 in timePoints if t1 <= t <= t2]
            timeMatch = bool(x)
        if regexps:
            g = [record.subject, record.scene, record.people, record.tag]
            if not record.binary:
                g.append(record.data)

            if matchAll:
                matcher = lambda ps, f: len([1 for p in ps if re.search(p, f)]) == len(ps)
            else:
                matcher = lambda ps, f: bool([1 for p in ps if re.search(p, f)])
            x = [True for f in g if matcher(regexps, f)]
            regMatch = bool(x)
        return timeMatch and regMatch

    return logFilter


def help(ofile=sys.stdout):
    bname = os.path.basename(sys.argv[0])
    msg =  "Usage:\n\n"
    msg += "------- Adding -------\n"
    msg += "%s add -s subject\n" % bname
    msg += "cmd | %s add -s subject\n" % bname
    msg += "%s add -s subject -d data\n" % bname
    msg += "%s add -g tag -t time -c scene -p people -s subject -d data\n\n" % bname

    msg += "------- Listing -------\n"
    msg += "%s list                         -- list all\n" % bname
    msg += "%s list 2016                    -- in 2016\n" % bname
    msg += "%s list 201601                  -- in Jan. 2016\n" % bname
    msg += "%s list 20160107                -- on Jan. 7th 2016\n" % bname
    msg += "%s list -7                      -- the 7th day before\n" % bname
    msg += "%s list 3:5                     -- 3th through 5th this month\n" % bname
    msg += "%s list -2:today                -- from the day before yesterday up to today\n" % bname
    msg += "%s list -2:                     -- from the day before yesterday up to today\n" % bname
    msg += "%s list 0703:0909               -- 3rd Jul. through 9th Sep. this year\n" % bname
    msg += "%s list 20150101:today          -- from Jan. 1st 2015 up to today\n" % bname
    msg += "%s list 20160101,3:5,-2,12      -- any day matches the comma separated list\n" % bname
    msg += "%s list -Sre                    -- regular expression match for any text fields\n" % bname
    msg += "%s list -Sre -Sre               -- match any of the regular expression\n" % bname
    msg += "%s list -Sre -Sre --all-match   -- match all of the regular expressions\n" % bname
    msg += "%s list 3:5 -Sre                -- regular expression match for any text fields\n" % bname
    print(msg)


if __name__ == '__main__':
    try:
        cmd = sys.argv[1]
    except IndexError:
        help(ofile=sys.stderr)
        exit(1)

    try:
        if cmd == 'add':
            add(sys.argv[2:])
        elif cmd == 'list':
            _list(sys.argv[2:])
    except AssertionError as e:
        print(e, file=sys.stderr)
        help(ofile=sys.stderr)
        exit(1)
