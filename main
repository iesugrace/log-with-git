#!/usr/bin/env python3
# Author: Joshua Chen
# Date: 2016-01-03
# Location: Shenzhen
# Description: a log tool with encrypted remote backup.

import sys, os
import re
import time
from subprocess import Popen, PIPE

prog_path = os.path.realpath(__file__)
prog_dir  = os.path.dirname(prog_path)
lib_dir   = os.path.join(prog_dir, 'lib')
sys.path.insert(0, lib_dir)

from common import editContent
import interact
import timeutils
import lib

# A global dictionary to hold all configs,
# some classes reference this variable
appConfigs = {}

class Config:
    """ Process and store the user settings
    """
    defaultConfigName = '.logrc'

    def __init__(self, path=None):
        """ Rule for the dataDir:
        1. exists and is a directory, or
        2. not yet exists
        """
        if not path:
            path = os.path.join(os.getenv('HOME'), self.defaultConfigName)
        code       = open(path).read()
        configs    = {}
        exec(code, configs)
        configs    = {k: v for k, v in configs.items() if k[0] != '_'}
        self.data  = configs
        dataDir    = configs.get('dataDir')
        dataDirSet = False
        if dataDir and (
            os.path.isdir(dataDir) or
            not os.path.exists(dataDir)):
                dataDirSet = True
        assert dataDirSet, "config: no appropriate data directory"
        assert configs.get('authorName'), "config: author name not set"
        assert configs.get('authorEmail'), "config: author email not set"


class Record:
    """ Define the fields and methods of a record
    Fields and types:
    subject  --  str
    author   --  str
    time     --  int
    scene    --  str
    people   --  str
    tag      --  str
    data     --  str (maybe base64 text for binary data)
    """
    sep = ':'  # separator between key and value

    def __init__(self, subject, author, time=None, scene='',
                        people='', tag='', data='', path=None):
        time = time if time else timeutils.isodatetime()
        self.subject   =  subject
        self.author    =  author
        self.time      =  timeutils.strtosecond(time)
        self.scene     =  scene
        self.people    =  people
        self.tag       =  tag
        self.data      =  data
        self.path      =  path

    def __repr__(self):
        text = '%s\n\n%s' % (self.__header(), self.subject)
        if self.binary:
            data = "-->> Binary data <<--"
        else:
            data = self.data
        if data:
            text = '%s\n\n%s' % (text, data.rstrip('\n'))
        return text

    def __header(self):
        """ Construct the header of the Log
        Return a str object, no ending new-line.
        """
        keys   = ['Author', 'Time', 'Scene', 'People', 'Tag']
        keys   = [x + self.sep for x in keys]   # append the separator
        values = [self.author, timeutils.isodatetime(self.time),
                        self.scene, self.people, self.tag]
        maxlen = max([len(x) for x in keys])
        fmt    = '%%-%ds %%s\n' % maxlen
        text   = ''
        for k, v in zip(keys, values):
            if v:
                text += fmt % (k, v)
        id     = os.path.basename(self.path) if self.path else 'N/A'
        text   = 'log %s\n%s' % (id, text[:-1])
        return text     # remove the last new-line

    def elements(self):
        """ Return a dictionary containing
        all elements of the record
        """
        return self.__dict__


class Git:
    """ Git related operations
    """
    SUCCESS  = 0
    TOFETCH  = 1
    CONFLICT = 2
    NOREMOTE = 3
    UNKNOWN  = 4

    def __init__(self, gitWorkTree, gitDir=None):
        if gitDir is None:
            gitDir = os.path.join(gitWorkTree, '.git')
        self.gitWorkTree = gitWorkTree
        self.gitDir      = gitDir
        if not os.path.exists(gitDir):
            self.init()

    def commit(self, paths, message):
        """ Add the files of paths and create a commit
        """
        cmd = ['git', 'add', '-A'] + paths
        res = self.runCmd(cmd)
        if not res[0]:
            return False
        cmd = ['git', 'commit', '-m', message]
        self.runCmd(cmd)

    def init(self):
        """ Initialize a git repository
        """
        cmd = ['git', 'init']
        self.runCmd(cmd)

    def runCmd(self, cmd, quiet=False):
        """ Switch the working directory to the
        GIT_DIR, then run git command there,
        and then switch back.
        """
        owd = os.getcwd()
        os.chdir(self.gitWorkTree)
        res = lib.get_status_byte_output(cmd)
        if not res[0] and not quiet:
            print('git command failed:', file=sys.stderr)
            print(res[2].decode(), file=sys.stderr, end='')
        os.chdir(owd)
        return res

    def last(self):
        """ Return the file content of the last commit
        it shall be one file only.
        """
        return None

    def shadowInit(self):
        """ Initialize the shadow git
        """
        cmd = ['git', 'shadow-init', '-s']
        stat, *junk = self.runCmd(cmd, quiet=True)
        if stat:
            return True
        print('shadow git not yet initialized')
        owd = os.getcwd()
        os.chdir(self.gitWorkTree)
        stat = os.system('git shadow-init')
        os.chdir(owd)
        return stat == 0

    def setRemote(self, remote):
        """ Add the remote to git if it does not yet exist
        """
        cmd = ['git', 'remote']
        stat, stdout, stderr = self.runCmd(cmd, quiet=True)
        lines = stdout.split(b'\n')
        if remote.encode() in lines:
            return True
        print('remote "%s" not exists, adding...' % remote)
        addr = interact.readstr('addr: ')
        cmd = ['git', 'remote', 'add', remote, addr]
        stat, stdout, stderr = self.runCmd(cmd, quiet=True)
        return stat

    def shadowPush(self, remote, branch='master'):
        """ Do a shadow-push
        """
        cmd = ['git', 'shadow-push', remote, branch]
        stat, stdout, stderr = self.runCmd(cmd, quiet=True)
        if not stat:
            if (b'[rejected]' in stderr and
                (b'the remote contains work' in stderr or
                 b'non-fast-forward' in stderr)):
                code = Git.TOFETCH
            else:
                code = Git.UNKNOWN
        else:
            code = Git.SUCCESS
        return (code, stderr)

    def shadowFetch(self, remote, branch='master'):
        """ Do a shadow-fetch
        """
        cmd = ['git', 'shadow-fetch', remote, branch]
        stat, stdout, stderr = self.runCmd(cmd, quiet=True)
        return (stat, stderr)

    def shadowMerge(self, remote, branch='master'):
        """ Do a shadow-merge
        """
        code = Git.UNKNOWN
        cmd  = ['git', 'checkout', branch]
        stat, stdout, stderr = self.runCmd(cmd, quiet=True)
        if stat:
            plainBranch = 'plain-%s-%s' % (remote, branch)
            cmd = ['git', 'shadow-merge', plainBranch]
            stat, stdout, stderr = self.runCmd(cmd, quiet=True)
            if not stat:
                if b'CONFLICT' in stderr:
                    code = Git.CONFLICT
            else:
                code = Git.SUCCESS
        return (code, stderr)

    def allRemotes(self):
        """ Return a list of all remotes
        """
        cmd  = ['git', 'remote']
        stat, stdout, stderr = self.runCmd(cmd, quiet=True)
        res = stdout.decode().split('\n')
        res = [x for x in res if x]
        return res


class LogRecord(Record):
    """ Log Record capable of Git operations
    OS aware operations defined here.
    """
    def __init__(self, subject, author, time=None, scene='', people='',
                    tag='', data='', binary=False, path=None):
        Record.__init__(self, subject, author, time,
                        scene, people, tag, data, path)
        self.binary      = binary

    def save(self, fileName=None):
        """ Save instance data to disk
        """
        timestamp  =  self.time
        dateEle    =  timeutils.isodate(timestamp).split('-')
        absDirPath =  os.path.join(appConfigs['dataDir'], *dateEle)
        if not fileName:
            fileName = self.genName(timestamp)
        filePath   =  os.path.join(absDirPath, fileName)
        os.makedirs(absDirPath, exist_ok=True)
        self.engine.save(self, filePath)
        return filePath

    def genName(self, timestamp):
        """ Generate a file name base on the timestamp,
        and some random string, the result is a sha1 sum.
        """
        import random, hashlib
        s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
        res = ''
        length = 10
        for i in range(length):
            res += random.choice(s)
        string = ('%s%s' % (timestamp, res)).encode()
        return hashlib.sha1(string).hexdigest()

    def __eq__(self, log):
        """ compare with another log, if are equal
        """
        return (self.people  == log.people and
                self.time    == log.time   and
                self.author  == log.author and
                self.tag     == log.tag    and
                self.binary  == log.binary and
                self.scene   == log.scene  and
                self.data    == log.data   and
                self.data    == log.data   and
                self.subject == log.subject)

    def __ne__(self, log):
        """ compare with another log, if are not equal
        """
        return not self.__eq__(log)

    @staticmethod
    def load(path):
        return LogRecord.engine.load(path)


class XmlStorage:
    """ XML storage engine for the record
    """
    @staticmethod
    def sourceToDom(code):
        """ Parse the raw record data which is XML code,
        return a Xml DOM object.
        """
        from xml.dom.minidom import parseString
        return parseString(code)

    @staticmethod
    def load(path):
        """ Load the content of the path,
        parse it, and return a record instance.
        """
        try:
            code = open(path).read()
            doc  = XmlStorage.sourceToDom(code)
        except:
            return None
        fields = {}
        for node in doc.firstChild.childNodes:
            if node.nodeType == node.ELEMENT_NODE:
                name = node.localName
                textNode = node.firstChild
                data = textNode.data if textNode else ''
                fields[name] = data
        fields['binary'] = True if fields['binary'] == 'true' else False
        fields['path'] = path
        return LogRecord(**fields)

    @staticmethod
    def createNode(root, nodeName, nodeText):
        """ Add an element node with nodeText to the 'root' element
        """
        from xml.dom.minidom import Element, Text
        ele = Element(nodeName)
        text = Text()
        text.data = nodeText
        ele.appendChild(text)
        root.appendChild(ele)

    @staticmethod
    def recordToSource(record):
        """ Compose Xml source code from a record object
        """
        from xml.dom.minidom import Document, Text
        import re
        doc  = Document()
        root = doc.createElement("log")
        doc.appendChild(root)
        XmlStorage.createNode(root, "subject", record.subject)
        XmlStorage.createNode(root, "author", record.author)
        XmlStorage.createNode(root, "time", timeutils.isodatetime(record.time))
        XmlStorage.createNode(root, "scene", record.scene)
        XmlStorage.createNode(root, "people", record.people)
        XmlStorage.createNode(root, "tag", record.tag)
        if record.binary:
            XmlStorage.createNode(root, "binary", "true")
        else:
            XmlStorage.createNode(root, "binary", "false")
        XmlStorage.createNode(root, "data", record.data)
        xmlCode = doc.toprettyxml()
        xmlCode = re.sub('\n(\s*\n)*', '\n', xmlCode)  # remove empty lines
        xmlCode = re.sub('\t', '    ', xmlCode)     # replace tabs with spaces
        return xmlCode

    @staticmethod
    def save(record, path):
        """ Convert the record to Xml code,
        and Write the code to the path.
        """
        code = XmlStorage.recordToSource(record)
        open(path, 'w').write(code)


# Register storage engine
LogRecord.engine = XmlStorage


class Log:
    """ All log operations defined here
    """

    def __init__(self):
        dataDir = appConfigs['dataDir']
        os.makedirs(dataDir, exist_ok=True)
        self.git = Git(dataDir)

    def lastScene(self):
        """ Fetch the recently used scene from the history
        """
        path = self.git.last()
        if path != None:
            record = LogRecord.engine.load(path)
            if record != None:
                return record.scene
        return ''

    def add(self, subject='', time=None, scene='', people='',
            tag='', data=b'', binary=False, interactive=False):
        """ Add a log record to the system
        When interactive is True, ask data for subject, time, scene,
        people, tag, and log data from the use interactively, the
        provided arguments are used as the default value for user's
        choice.
        """

        author = '%s <%s>' % (appConfigs['authorName'],
                              appConfigs['authorEmail'])
        if interactive:
            record = self.makeLogEntry(subject=subject, author=author,
                                       time=time, scene=scene, people=people,
                                       tag=tag, data=data, binary=binary)
        else:
            assert (subject != None and subject != ''), "invalid subject"
            if not binary:
                data = data.decode()
            record = LogRecord(subject, author, time, scene,
                               people, tag, data, binary)
        path  = record.save()
        bname = os.path.basename(path)
        message = 'Add log\n\n%s' % bname
        self.git.commit([path], message)

    def makeOneRequest(self, name, default, datatype, reader, desc):
        """ Create a request entry, used to interactively collect
        information from the user. A request is a dictionary object
        that contains necessary information to interact with the user.
        """
        suffix = (' [%s]: ' % default) if default else ': '
        prompt = desc + suffix
        if reader:
            actual_reader = (lambda prompt, default: reader(prompt, default))
        else:
            actual_reader = reader
        return dict(name=name, prompt=prompt, datatype=datatype,
                    default=default, reader=actual_reader)

    def makeRequests(self, *, record=None, time=None,
                    scene=None, people=None, tag=None):
        """ Create the necessary requests data for collecting
        information for a Record from the user interactively.
        """
        if record:      # a LogRecord instance provided
            time     =  record.time
            scene    =  record.scene
            people   =  record.people
            tag      =  record.tag
        else:
            time = time if time else timeutils.isodatetime()
            scene = scene if scene else self.lastScene()
            people = people if people else ''
            tag = tag if tag else ''

        requests = []
        # arguments: name, default, datatype, reader, desc
        requests.append(self.makeOneRequest('time',    time,    str, None, 'time'))
        requests.append(self.makeOneRequest('scene',   scene,   str, None, 'scene'))
        requests.append(self.makeOneRequest('people',  people,  str, None, 'people'))
        requests.append(self.makeOneRequest('tag',     tag,     str, None, 'tag'))
        return requests

    def makeLogEntry(self, *junk, **args):
        """ Make a LogRecord instance interactively
        'data' in the args must be a bytes which can
        be decoded using utf8, binary data that is
        not utf8 encoded, is not applicable.
        """
        data     = args.pop('data')
        binary   = args.pop('binary')
        subject  = args.pop('subject')
        author   = args.pop('author')

        # read subject and data from editor
        if binary:
            iData =  b'\n# Binary data is provided, therefore only the first\n'
            iData += b'# line will be used for subject, empty message aborts.\n'
        elif subject:
            iData = subject.encode()
            if data:
                iData += b'\n\n' + data
        else:
            iData = b''
        oData    = editContent(iData).decode()
        msgLines = oData.split('\n\n')
        subject  = msgLines.pop(0).strip()
        if not binary:  # accept data from editor only for non-binary
            data = '\n\n'.join(msgLines)

        # empty subject, abort
        assert subject != '', "aborting due to empty subject"

        # read other info
        requests = self.makeRequests(**args)
        i        = interact.readMany(requests)
        time     =  i['time']
        scene    =  i['scene']
        people   =  i['people']
        tag      =  i['tag']

        return LogRecord(subject, author, time, scene, people, tag, data, binary)

    def allLogPaths(self):
        """ Return all log records' paths in the file
        system, return a generator.
        """
        dataDir = appConfigs['dataDir']
        cmd = ['find', dataDir, '-name', '.git', '-prune', '-o', '-type', 'f', '-print0']
        res = lib.get_status_byte_output(cmd)
        if not res[0]:
            print('find command failed:', file=sys.stderr)
            print(res[2].decode(), file=sys.stderr, end='')
            return

        lines = res[1].split(b'\x00')[:-1]   # remove the last empty one
        for path in lines:
            yield path.decode()

    def collectLogs(self, filter=None):
        """ Walk through all log records, collect those
        that passed the filter function matching. Return
        a generator which yields LogRecord instances.
        """
        if not filter:
            filter = lambda record: True
        paths = self.allLogPaths()
        for path in paths:
            record = LogRecord.load(path)
            if filter(record):
                yield record

    def delete(self, ids, force=False):
        """ Delete the logs whose id is in 'ids', confirm
        before deleting if force is False, partial ID is
        acceptable, so that 297aacc is equivalent of
        297aacc3863171ed86ba89a2ea0e88f9c4d99d48.
        """
        paths = self.allLogPaths()
        paths = [path for path in paths for id in ids
                    if id and os.path.basename(path).startswith(id)]
        deletedPaths = []
        for path in paths:
            bname  = os.path.basename(path)
            if not force:
                record = LogRecord.load(path)
                msg = 'delete %s: %s? ' % (bname, record.subject)
                ans = interact.readstr(msg, default='N')
                if ans != 'y':
                    continue
            os.remove(path)
            deletedPaths.append(path)
            print('deleted %s' % bname)
        if deletedPaths:
            bnames = [os.path.basename(x) for x in deletedPaths]
            message = 'Delete log\n\n%s' % '\n'.join(bnames)
            self.git.commit(deletedPaths, message)

    def edit(self, id):
        """ Edit the log of the given id
        The edited log may be saved to a new directory
        if its timestamp changed, in such case the old
        log will be deleted.
        """
        paths        = self.allLogPaths()
        changedFiles = []
        for path in paths:
            if os.path.basename(path).startswith(id):
                oldRecord = LogRecord.load(path)
                elements  = dict(oldRecord.elements())
                oldPath   = elements.pop('path')
                elements['data'] = elements['data'].encode()
                elements['time'] = timeutils.isodatetime(elements['time'])
                newRecord = self.makeLogEntry(**elements)
                if newRecord != oldRecord:
                    if newRecord.time != oldRecord.time:
                        os.remove(oldPath)
                        changedFiles.append(oldPath)
                    fileName = os.path.basename(oldPath)
                    newPath  = newRecord.save(fileName)
                    changedFiles.append(newPath)
                    message  =  'Change log\n\n%s' % fileName
                    self.git.commit(changedFiles, message)
                break

    def push(self, remote):
        """ Sync with the git server

        Push using shadow-git tools, first shadow-push,
        if rejected because of unfetched update on the
        server side, do a shadow-fetch and shadow-merge,
        then a shadow-push again. In case of conflict
        that can not be automatically resolved, exit,
        after manually solved the conflict, user can
        then try to push again.
        """
        def error(msg):
            print(msg, file=sys.stderr)

        if not self.preAction(remote):
            return False

        for i in range(2):              # try twice at most
            print('pushing...')
            stat, msg = self.git.shadowPush(remote)
            if stat == Git.TOFETCH:
                print('push rejected, need to fetch')
                if self.fetch(remote):
                    continue
            elif stat == Git.UNKNOWN:
                error('unknown error:\n' + msg.decode())
            elif stat == Git.SUCCESS:
                print('push done.')
                return True
            return False


    def preAction(self, remote):
        """ Actions to carry out before push/fetch
        """
        if not self.git.shadowInit():
            return False
        if not self.git.setRemote(remote):
            return False
        return True


    def fetch(self, remote):
        """ Fetch from the git server
        """
        def error(msg):
            print(msg, file=sys.stderr)

        if not self.preAction(remote):
            return False

        print('fetching...')
        stat, msg = self.git.shadowFetch(remote)
        if not stat:
            error('fetch failed:\n' + msg.decode())
        else:
            print('merging...')
            stat, msg = self.git.shadowMerge(remote)
            if stat == Git.SUCCESS:
                print('fetch done.')
                return True
            elif stat == Git.UNKNOWN:
                error('unknown error:\n' + msg.decode())
            elif stat == Git.CONFLICT:
                error('automatic merge failed, fix the conflict, and retry')
        return False


def add(args):
    """ Add a log
    Subject is required, data is not. If message provided,
    all lines before an empty line will serve as the subject,
    and the rest as the data. If the subject or the data is
    not available from the argument, then read from the
    stdin if the stdin is not a tty. If the data from stdin
    can not be correctly decoded (binary) to provide the
    missing subject, enter interactive mode and open up an
    editor to collect information.

    Priority of the source of subject and data, descending:

        cmdline arguments --> stdin --> editor

    """
    if '--help' in args:
        help('add')
        exit(0)

    tag = time = scene = people = message = subject = ''
    data = b''
    binary = False
    while len(args) >= 2:
        key = args.pop(0)
        if key == '-g':
            tag = args.pop(0)
        elif key == '-t':
            time = args.pop(0)
        elif key == '-c':
            scene = args.pop(0)
        elif key == '-p':
            people = args.pop(0)
        elif key == '-m':
            message  = args.pop(0)
    # subject and data from command line
    if message:
        msgLines = message.rstrip('\n').split('\n\n')
        subject  = msgLines.pop(0)
        data     = '\n\n'.join(msgLines).encode()

    interactive = not subject
    if interactive and not os.isatty(sys.stdin.fileno()):
        raise lib.NotTerminalException("stdin is not a terminal")

    # data from stdin
    if not data and not os.isatty(sys.stdin.fileno()):
        stdin = os.fdopen(sys.stdin.fileno(), 'rb')
        iData = stdin.read()
        if lib.isBinary(iData):
            binary = True
            data   = lib.binToAsc(iData).encode()
        else:
            binary = False
            data   = iData

    logger      = Log()
    logger.add(subject, time, scene, people, tag, data, binary, interactive)


def _list(args):
    """ List log summary

    Can match log entries by time, or by regular expression.

    Time format (implemented in compreDay):
        today: the day when the command runs
        negative number: N-th day ago (-1, -70)
        one or two digit number: a day of a month (1, 12)
        four digit number: a day of the specific month  (0413, 0314)
        four digit number: a year  (2015, 2016)
        six digit number: a month of a year  (201512, 201601)
        eight digit number: a day of a month of a year  (20160101)

    Time contextual meaning (implemented in parseTime):
        a. pure number/word: from the first second of it,
                             to the last second of it
        b. colon separated : from the first second of the first,
                             to the last second of the second,
                             'today' next to the colon can be omitted.
        c. comma separated: combination of 'a' or 'b' types
    """
    if '--help' in args:
        help('list')
        exit(0)

    remainOpts = []
    if len(args) == 0:  # list all records
        filterFunc = lambda record: True
    else:
        filterFunc, remainOpts = procArgs(args)
    limit   = extractLimitArgs(remainOpts)
    logger  = Log()
    records = logger.collectLogs(filterFunc)
    records = sorted(records, key=lambda x: x.time, reverse=True)
    if limit:
        records = records[:limit]
    pageOut(records)


def extractLimitArgs(args):
    """ Get all limit arguments out of the args, return the last one.
    """
    argsCopy = args[:]
    limit    = None
    for arg in argsCopy:
        if re.search('^-[1-9][0-9]*$', arg):
            limit = arg
            args.remove(arg)
    if limit:
        limit = int(limit[1:])
    return limit


def pageOut(records):
    """ Apply color to the text, pipe the
    text to a pager, for a better viewing.
    """
    def colorize(record):
        """ Render the first line
        """
        text = str(record)
        if os.isatty(sys.stdout.fileno()):
            pos     = text.find('\n')
            id      = text[:pos]
            cFormat = '\033[0;33m%s\033[0m'
            id      = cFormat % id
            text    = id + text[pos:]
        return text

    if not records:
        return
    lastOne = records.pop()
    pager   = lib.Pager(['-XRF'])
    for record in records:
        pager.write(colorize(record), '\n\n', isBytes=False)
    pager.write(colorize(lastOne), '\n', isBytes=False)
    pager.go()


def procArgs(args):
    """ Process the arguments, return a filter function.
    """
    regexps    = []
    matchAll   = False
    timePoints = []
    remainOpts = []
    while args:
        arg = args.pop(0)
        if arg[:2] == '-S':     # regular expression
            if len(arg) > 2:
                regexps.append(arg[2:])
            else:
                assert len(args) > 0, "need argument for -S option"
                regexps.append(args.pop(0))
        elif arg == '--all-match':  # affects the RE evaluation
            matchAll = True
        elif arg[:2] == '-t':   # time
            if len(arg) > 2:
                timeArg = arg[2:]
            else:
                assert len(args) > 0, "need argument for -t option"
                timeArg = args.pop(0)
            assert validateTime(timeArg), ("invalid time: %s" % timeArg)
            timePoints.extend(parseTime(timeArg))
        elif re.search('^-[1-9][0-9]*$', arg):
            remainOpts.append(arg)
        else:
            assert False, "unrecognized option: %s" % arg
    return makeFilter(timePoints, regexps, matchAll), remainOpts


def validateTime(timeStr):
    """ Check the time string format
    Only check the textual format, not the meaning
    of the time string, therefore 20160230 is valid.
    """
    if timeStr == 'today':
        return True

    lev1_parts = timeStr.split(',')
    for lev1_part in lev1_parts:
        lev2_parts = lev1_part.split(':')
        for x in lev2_parts:
            # empty means 'today'
            regexp = '^(today|-[0-9]+|[0-9]{1,2}|[0-9]{4}|[0-9]{6}|[0-9]{8})?$'
            if re.search(regexp, x) is None:
                return False
    return True


def parseTime(timeStr):
    """ Parse the time string, return a list of lists,
    every inner list represents a period of time between
    two points, the relationship between all inner lists
    is OR, not AND.
    """
    if timeStr == 'today':
        return [todayPeriod()]

    allPairs   = []
    lev1_parts = timeStr.split(',')
    for lev1_part in lev1_parts:
        lev2_parts = lev1_part.split(':')
        if len(lev2_parts) == 2: # start time and end time
            firstSecond, junk = compreTime(lev2_parts[0])
            junk, lastSecond  = compreTime(lev2_parts[1])
            allPairs.append([firstSecond, lastSecond])
        else:   # one time
            pair = compreTime(lev2_parts[0])
            allPairs.append(pair)
    return allPairs


def todayPeriod():
    """ Return the first and the last seconds of today
    """
    return dayPeriod()


def dayPeriod(ts=None):
    """ Return the first and the last seconds
    of a day, 'ts' is a time.struct_time object,
    if omitted, assume the current time.
    """
    if ts is None:
        ts = time.localtime()
    ts1 = time.strptime('%d%02d%02d' % ts[:3], '%Y%m%d')
    firstSecond = int(time.mktime(ts1))
    timeStr = '%d%02d%02d%02d%02d%02d' % (ts[:3] + (23, 59, 59))
    ts2 = time.strptime(timeStr, '%Y%m%d%H%M%S')
    lastSecond  = int(time.mktime(ts2))
    return [firstSecond, lastSecond]


def compreTime(text):
    """ Distinguish between year and other
    time format, call compreYear and compreDay
    accordingly. Empty string means 'today'.
    """
    if not text:
        return todayPeriod()
    if len(text) == 4 and text[:2] == '20':
        return compreYear(text)
    else:
        return compreDay(text)


def compreYear(text):
    """ Take the given number string as a year, return
    the first second and the last second of the year.
    """
    firstDay = time.strptime(text, '%Y')
    lastDay  = time.strptime('%s%s%s' % (text, '12', '31'), '%Y%m%d')
    firstSecond, junk = dayPeriod(firstDay)
    junk, lastSecond  = dayPeriod(lastDay)
    return [firstSecond, lastSecond]


def compreDay(text):
    """ Parse the given number string, return the
    first second and the last second of the day.
    """
    l = len(text)

    try:
        if text[0] == '-':          # negative day
            days = int(text)
            second = time.time() + 86400 * days
            res = time.localtime(second)
        elif 1 <= l <= 2:           # a day of the current month
            y, m = time.localtime()[:2]
            d = int(text)
            res = time.strptime('%s%02d%02d' % (y, m, d), '%Y%m%d')
        elif l == 4:                # day of a specific month
            y = time.localtime()[0]
            res = time.strptime('%s%s' % (y, text), '%Y%m%d')
        elif l == 6:                # month of a specific year
            res = time.strptime(text, '%Y%m')
        elif l == 8:                # a day of a month of a year
            res = time.strptime(text, '%Y%m%d')
    except:
        raise lib.InvalidTimeException("invalid time: %s" % text)
    return dayPeriod(res)


def makeFilter(timePoints, regexps, matchAll=False):
    """ Create a filter function for filtering
    the record with the given regular expression,
    and the time points. The filter function
    expects a LogRecord instance object.
    """
    def logFilter(record, regexps=regexps,
                timePoints=timePoints, matchAll=matchAll):
        """ timeMatch is True if the time of the record is
        within any pair of the timePoints, regMatch is True
        if any of these fields of a record match the given
        regular expression: subject, scene, people, tag,
        and data if it's not of binary form. Return True
        only when both timeMatch and regMatch are True.
        """
        timeMatch = regMatch = True
        if timePoints:
            t = record.time
            x = [True for t1, t2 in timePoints if t1 <= t <= t2]
            timeMatch = bool(x)
        if regexps:
            g = [record.subject, record.scene, record.people, record.tag]
            if not record.binary:
                g.append(record.data)

            if matchAll:
                matcher = lambda ps, f: len([1 for p in ps if re.search(p, f)]) == len(ps)
            else:
                matcher = lambda ps, f: bool([1 for p in ps if re.search(p, f)])
            x = [True for f in g if matcher(regexps, f)]
            regMatch = bool(x)
        return timeMatch and regMatch

    return logFilter


def delete(args):
    """ Delete logs

    Identify logs by the ID, multiple IDs are accepted,
    either from the command line, or from a file; the
    file shall have one line for one ID.
    """
    if '--help' in args:
        help('del')
        exit(0)

    ids   = []
    ifile = None
    force = False
    while args:
        arg = args.pop(0)
        if arg[:2] == '-i':     # input file
            if len(arg) > 2:
                ifile = arg[2:]
            else:
                assert len(args) > 0, "need argument for -i option"
                ifile = args.pop(0)
        elif arg == '-f':
            force = True
        else:   # log ID
            ids.append(arg)
    if ifile:
        lines = open(ifile).readlines()
        lines = [x.rstrip() for x in lines if len(x) > 1]
        ids.extend(lines)
    assert ids, "no IDs provided"
    ids    = set(ids)
    logger = Log()
    logger.delete(ids, force=force)


def edit(args):
    """ Edit a log

    If the time of the log been changed, move
    the file of the log to the appropriate
    new parent directory.
    """
    if '--help' in args:
        help('edit')
        exit(0)

    assert len(args) == 1, "wrong arguments"
    id     = args[0]
    assert id, "wrong arguments"
    logger = Log()
    logger.edit(id)


def push(args):
    """ Sync with the git server
    """
    if '--help' in args:
        help('push')
        exit(0)

    logger     = Log()
    remotes    = []
    allRemotes = False
    while args:
        arg = args.pop(0)
        if arg == '-a':
            remotes    = logger.git.allRemotes()
            allRemotes = True
            break
        else:
            remotes.append(arg)
    if not remotes and not allRemotes:
        remotes = ['origin']
    for remote in remotes:
        print('pushing to "%s"' % remote)
        stat = logger.push(remote)
        if not stat:
            break
    exit(0 if stat else 1)


def fetch(args):
    """ Download changes from the git server
    """
    if '--help' in args:
        help('fetch')
        exit(0)

    logger     = Log()
    remotes    = []
    allRemotes = False
    while args:
        arg = args.pop(0)
        if arg == '-a':
            remotes    = logger.git.allRemotes()
            allRemotes = True
            break
        else:
            remotes.append(arg)
    if not remotes and not allRemotes:
        remotes = ['origin']
    for remote in remotes:
        print('fetching from "%s"' % remote)
        stat = logger.fetch(remote)
        if not stat:
            break
    exit(0 if stat else 1)


def clone(args):
    """ Clone the repository from the remote
    """
    if '--help' in args:
        help('clone')
        exit(0)

    assert len(args) == 1, "wrong arguments"
    remote  = args[0]
    dataDir = appConfigs['dataDir']
    stat    = os.system('git shadow-clone %s %s' % (remote, dataDir))
    exit(0 if stat else 1)


def help(cate=None):
    bname = os.path.basename(sys.argv[0])
    defaultMsg = "Usage: %s <command> [option [argument]]... [-F config]\n"
    defaultMsg += "       %s <command> --help"
    defaultMsg = defaultMsg % ((bname,) * 2)

    addMsg = """%s add
%s add -m message
%s add -m message < file
pipe | %s add -m message
%s add -g tag -t time -c scene -p people -m message""" % ((bname,) * 5)

    listMsg = """%s list                             -- list all
%s list -3                          -- show the last three log
%s list -t 2016                     -- in 2016
%s list -t 201601                   -- in Jan. 2016
%s list -t 20160107                 -- on Jan. 7th 2016
%s list -t -7                       -- the 7th day before
%s list -t 3:5                      -- 3th through 5th this month
%s list -t -2:today                 -- from the day before yesterday up to today
%s list -t -2:                      -- from the day before yesterday up to today
%s list -t 0703:0909                -- 3rd Jul. through 9th Sep. this year
%s list -t 20150101:today           -- from Jan. 1st 2015 up to today
%s list -t 20160101,3:5,-2,12       -- any day matches the comma separated list
%s list -Sre                        -- regular expression match for any text fields
%s list -Sre -Sre                   -- match any of the regular expression
%s list -Sre -Sre --all-match       -- match all of the regular expressions
%s list -t 3:5 -Sre                 -- regular expression match for any text fields""" % ((bname,) * 16)

    delMsg = """%s del 297aacc                  -- delete log whose id starts with 297aacc
%s del 297aacc 5e0df2c          -- delete multiple logs
%s del -f 297aacc               -- delete without confirmation
%s del -i list-of-file          -- get log IDs from a file""" % ((bname,) * 4)

    editMsg = "%s edit 297aacc" % bname

    pushMsg = """%s push origin                  -- push to remote 'origin'
%s push origin github           -- push to remote 'origin' and 'github'
%s push -a                      -- push to all remotes""" % ((bname,) * 3)

    fetchMsg = """%s fetch origin                 -- fetch from remote 'origin'
%s fetch origin github          -- fetch from remote 'origin' and 'github'
%s fetch -a                     -- fetch from all remotes""" % ((bname,) * 3)

    cloneMsg = "%s clone REMOTE-URL" % bname

    if cate == 'add':
        msg = addMsg
    elif cate == 'list':
        msg = listMsg
    elif cate == 'del':
        msg = delMsg
    elif cate == 'edit':
        msg = editMsg
    elif cate == 'push':
        msg = pushMsg
    elif cate == 'fetch':
        msg = fetchMsg
    elif cate == 'clone':
        msg = cloneMsg
    else:
        msg = defaultMsg
    print(msg)


def loadConfig():
    if '-F' in sys.argv:
        idx = sys.argv.index('-F')
        sys.argv.pop(idx)
        assert len(sys.argv) > idx, "need argument for -F option"
        path = sys.argv.pop(idx)
    else:
        path = None

    config = Config(path)
    for k, v in config.data.items():
        appConfigs[k] = v


if __name__ == '__main__':
    ln = len(sys.argv)
    if ln == 1 or (ln == 2 and '--help' in sys.argv):
        help()
        exit(0)

    # load config from file
    try:
        loadConfig()
    except AssertionError:
        print(sys.exc_info()[1])
        exit(1)
    except:
        print(sys.exc_info()[1])
        help(ofile=sys.stderr)
        exit(1)

    # start to work
    try:
        cmd = sys.argv[1]
        if cmd == 'add':
            add(sys.argv[2:])
        elif cmd == 'del':
            delete(sys.argv[2:])
        elif cmd == 'edit':
            edit(sys.argv[2:])
        elif cmd == 'list':
            _list(sys.argv[2:])
        elif cmd == 'push':
            push(sys.argv[2:])
        elif cmd == 'fetch':
            fetch(sys.argv[2:])
        elif cmd == 'clone':
            clone(sys.argv[2:])
        else:
            raise lib.InvalidCmdException('unrecognized command: %s' % cmd)
    except IndexError:
        print('argument error', file=sys.stderr)
        help(ofile=sys.stderr)
        exit(1)
    except BrokenPipeError:
        pass
    except (AssertionError,
            lib.InvalidTimeException,
            lib.InvalidCmdException,
            lib.NotTerminalException) as e:
        print(e, file=sys.stderr)
        exit(1)
